<div class="search" data-active="{ !!search }">
	<input bind:value=search type="text" id="search" placeholder="Search" />
	<div class="closeSearch" on:click="set({ search: '' })">Ã—</div>
</div>

<div class="container">

	<div class="items { search == '' && 'full' }">
		{ #if items.length }
			{#each Object.entries(items) as [i, c]}
				{ #if search == '' && letters[i] }
					<div class="letter-heading" id="{ letters[i] }">{ letters[i] }</div>
				{ /if }
				<Chemical search={!search} {i} {...c} on:confirmSaveEL="confirmSaveEL(event)"  />
			{/each}
		{ :else }
			<div class="empty">No search results.</div>
		{ /if }
	</div>

	{ #if search == '' }
		<div class="alphabet">
			{ #each Object.entries(letters) as [i, l] }
				<div class="letter">{ l }</div>
			{ /each }
		</div>
	{ /if }

</div>

<Modal bind:show="ELModal">
	This will be set as the current job({$job.name})'s exposure limit.

	<div style="margin: 10px 0"><ExposureLimits exposureLimit="{ELModal}" /></div>

	<div class="buttons">
		<div class="button saveEL" on:click="saveEL(ELModal)">Okay</div>
		<div class="button neverMind" on:click="set({ ELModal: false })">Never mind</div>
	</div>
</Modal>

<script>

	import chemicals from 'data/chemicals.json'
	import letters from 'data/letters.json'
	import Fuse from 'fuse.js'

	var fuse = new Fuse(chemicals, {
		keys: [
			{
				name: 'name',
				weight: 0.8
			},
			{
				name: 'synonyms',
				weight: 0.5
			},
			{
				name: 'cas',
				weight: 0.9
			}
		],
		shouldSort: true,
		includeMatches: true,
		threshold: 0.3,
	})

	function propertiesMatch(a, b) {
		for(let k in a) if(a[k] !== b[k]) return false
		return true
	}

	export default {
		components: {
			ExposureLimits: 'lib/ExposureLimits.html',
			Modal: 'lib/Modal.html',
			Chemical: 'lib/Chemical.html'
		},
		data: () => ({
			search: '',
			letters,
			ELModal: false
		}),
		oncreate() {

			// scrolling through alphabet thingy
			let container = document.querySelector('.container')
			var mouseDown = false

			container.addEventListener('mousedown', down)
			container.addEventListener('touchstart', down)
			container.addEventListener('mouseup', up)
			container.addEventListener('touchend', up)
			container.addEventListener('touchcancel', up)

			function down(e) {
				if(e.target.className.indexOf('letter') > -1) {
					mouseDown = true
				}
			}
			function up() {
				mouseDown = false

				for(var l of document.querySelectorAll('.letter')) {
					l.classList.remove('active')
				}
			}

			container.addEventListener('mousemove', selectLetter)
			container.addEventListener('touchmove', selectLetter)
			container.addEventListener('click', selectLetter)

			function selectLetter(e) {
				var target
				if(e.type == 'touchmove') {
					let myLocation = e.touches[0];
					target = document.elementFromPoint(myLocation.clientX, myLocation.clientY);
				} else {
					target = e.target
				}

				if(mouseDown || e.type == 'click') {
					if(target.className && target.className.indexOf('letter') > -1) {
						e.preventDefault()

						var chemicalBox = document.querySelector('.items')
						var chemicalBoxOffset = chemicalBox.getBoundingClientRect()

						for(var l of document.querySelectorAll('.letter')) {
							l.classList.remove('active')
						}
						target.classList.add('active')

						var chemical = document.getElementById(target.innerText.toLowerCase())
						if(chemical) {
							var scrollTop = chemicalBox.scrollTop + chemical.getBoundingClientRect().top - chemicalBoxOffset.top - chemicalBoxOffset.height/3
							chemicalBox.scrollTop = scrollTop
						}
					}
				}
			}

			// save scroll position
			let chemicals = document.querySelector('.items')
			chemicals.scrollTop = this.store.get().job.chemicalsScrollTop
			var scrolls = 0

			chemicals.addEventListener('scroll', () => {
				let { job } = this.store.get()
				let { search } = this.get()
				if(search !== '') return
				// The first scroll is premature because the layout isn't finished.  When layout finishes, the browser wrongly scrolls again to compensate.  Set the scroll to the first scroll.
				if(scrolls < 2) {
					if(++scrolls == 1) {
						// first scroll
					} else {
						// second scroll
						chemicals.scrollTop = job.chemicalsScrollTop
					}
				} else {
					// subsequent scrolls
					this.store.set({ job: { chemicalsScrollTop: chemicals.scrollTop } })
				}
			})

			this.on('update', ({changed, current}) => {
				if(!changed.search) return
				if(current.search == '') {
					chemicals.scrollTop = this.store.get().job.chemicalsScrollTop
				} else {
					chemicals.scrollTop = 0
				}
			})

		},
		computed: {
			items: ({ search }) => {

				if(search === '') return chemicals

				var results = fuse.search(search)
					.filter(r => {
						// ignore results with just a bunch of empty matches
						var emptyMatches = r.matches.filter(m => m.value === '')
						return emptyMatches.length < r.matches.length
					})
					.slice(0, 50) // maximum number for rendering speed

				// highlight matched characters
				for(var r of results) {
					for(var m of r.matches) {
						var highlit = ''
						if(m.indices.length > 0) {
							highlit += m.value.slice(0, m.indices[0][0])
							for(var i = 0; i < m.indices.length; i++) {
								let indice = m.indices[i]
								
								highlit += '<em>' + m.value.slice(indice[0], indice[1]+1) + '</em>'
								if(i+1 < m.indices.length) {
									highlit += m.value.slice(indice[1]+1, m.indices[i+1][0])
								}							
							}
							highlit += m.value.slice(m.indices[m.indices.length-1][1]+1)
						}
						r.item[m.key + 'Highlit'] = highlit
					}
				}

				return results.map(r => r.item)
			}
		},
		methods: {
			confirmSaveEL(el) {
				this.set({ ELModal: el })
			},
			saveEL(el) {
				if(!propertiesMatch(el, this.store.get().job.exposureLimit)) {
					this.store.set({ job: { exposureLimit: el } })
					this.store.set({ job: { samples: false } }) // old samples invalid 
					this.store.set({ job: { samples: [] } }) // not sure why this is necessary, don't feel like investigating
					this.set({ ELModal: false })
				}
			}
		}
	}

</script>

<style>

	@import 'colors';

	.search {
		height: 50px;
		position: relative;
		padding: 10px;
		box-sizing: border-box;

		input {
			line-height: 30px;
			display: block;
			width: auto;
			padding: 0 10px;
			box-sizing: border-box;
			width: 100%;
			border: 1px solid #999;
			font-size: 120%;
		}

		&:after {
			position: absolute;
			right: 11px;
			top: 11px;
			display:inline-block;
			width: 30px;
			line-height: 30px;
			z-index: 2;
			text-align: center;
			color: #999;

			content: "\f002";
			/* use !important to prevent issues with browser extensions that change fonts */
			font-family: 'icomoon' !important;
			speak: none;
			font-style: normal;
			font-weight: normal;
			font-variant: normal;
			text-transform: none;

			/* Better Font Rendering =========== */
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
		}

		.closeSearch {
			cursor: pointer;
			display: none;
			width: 30px;
			text-align: center;
			position: absolute;
			top: 11px;
			right: 11px;
			font-size: 30px;
			line-height: 30px;
			z-index: 2;
		}

		&[data-active=true] {
			.closeSearch {
				display: block;
			}
			&:after {
				display: none;
			}
		}

	}
	.empty {
		font-size: 120%;
		color: #666;
		padding: 20px;
		text-align: center;
	}
	.letter-heading {
		font-size: 240%;
		text-transform: uppercase;
		padding-left: 10px;
	}
	.container {
		position: absolute;
		top: 50px;
		right: 0;
		bottom: 0;
		left: 0;

		.items {
			position: absolute;
			top: 0;
			left: 0;
			bottom: 0;
			overflow-y: scroll;
			overflow-x: hidden;
			right: 0;

			&.full {
				right: calc(2.65vh - 2.65px + 16px );
			}
		}
		.alphabet {
			position: absolute;
			top: 0;
			right: 0;
			bottom: 0;
			font-size: calc(2.65vh - 2.65px ); 
			overflow: hidden;

			div {
				user-select: none;
				cursor: pointer;
				width: calc(2.65vh - 2.65px );
				padding: 0 8px;
				text-transform: uppercase;
			}
		}
	}

	.buttons {
		text-align: right;
	}
	.saveEL.button {
		background: $green;
	}
	
</style> 
